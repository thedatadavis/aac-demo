## RFC: Adopting an "Accounting as Code" (AaC) Framework to build a scalable, auditable Finance function

1. Summary
Our key challenge is to master our complex, usage-based revenue model—which spans more than a dozen products—and to prepare for our first financial audit in 2026. The traditional, manual, spreadsheet-based approach to this is a fragile system held together by humans. It is slow, un-auditable, and a significant distraction.
This RFC proposes we formally adopt an "Accounting as Code" (AaC) framework. This means we treat our financial logic (revenue rules, chart of account mappings, journal entry templates) as version-controlled, testable code, managed in a Git repository.
I propose we build a "continuous close" process where a "Daily Close" is a Pull Request. This PR will run automated assertions (CI/CD) to validate our books daily. Merging it will be our auditable, human-in-the-loop (HITL) control.
This system is the best way to provide the deterministic compliance needed for our audit while aligning with our culture of transparency and autonomy.

2. The Problem: The Growing Complexity at PostHog
Our business model creates a technical accounting challenge that traditional tools can't solve:
 * Complex, Usage-Based Revenue: We have 14+ products with hybrid billing: PAYG, prepaid credits (for Startups and Enterprise), and amortized contracts. Manually calculating GAAP-compliant revenue (ASC 606) across millions of daily usage events is a non-starter.
 * Audit & Traceability: For our 2026 audit, we must provide complete event-to-revenue lineage. A spreadsheet-based model is a "black box" and will fail this test.
 * Speed & Efficiency: A manual month-end close is a slow, reactive process. This is a massive distraction that prevents us from getting real-time financial data, which is at odds with our cultural bias for speed and action.

3. The Solution: A PostHog-Native AaC Architecture
We will build a lightweight, programmable subledger that separates data (the what) from logic (the how).
 * Data Lake (The "What"): All raw financial events (Stripe invoices, Brex expenses, product usage data) land in our existing data lake. This is our single source of truth.
 * Git Repo (The "How"): A new finance-internal repo will house our codified financial logic in version-controlled YAML files:
   * config/chart_of_accounts.yml
   * config/je_templates.yml
   * rules/revenue_recognition.yml (This will codify our ASC 606 logic for all 14+ products).
 * The "Daily Close as a PR" (The "Workflow"):
   * Generate: An automated script runs daily, applies the YAML logic to the data lake data, and opens a PR.
   * Audit (CI/CD): A GitHub Action (our "Assertion Library") runs automated tests on the PR. This is our "checklist." It checks:
     * ASSERT: debits == credits
     * ASSERT: SUM(revenue_waterfall_schedules) == SUM(revenue_JEs)
     * ASSERT: Stripe_cash_balance == GL_cash_balance
   * Publish (HITL): As the Finance Manager, I review the passing checks (not the raw data). Merging this PR is the reliable SOX control, which posts the JEs to our ERP.

4. How This Aligns with Our Values
This isn't just a better system; it's a PostHog system.
 * Autonomy: This empowers the finance role to be the builder the job description calls for, not just a manual operator.
 * Transparency: We move from "black box" spreadsheets to a transparent, version-controlled Git repo. The logic for our finances is open for (internal) review.
 * Speed: We collapse the financial close from weeks to days by finding and fixing reconciliation errors daily, not 20 days after month-end.
 * Weirdness (in a good way): Most finance teams run on Excel and NetSuite. We will be running on Git, Python, and a data lake. This is our competitive advantage.

5. Proposed First Steps (MVC)
I am a hands-on builder and want to own daily accounting operations by building this.
 * Repo: Create the finance-internal repo and seed it with chart_of_accounts.yml.
 * Pipeline V1 (Ingest): Build the first dlt pipeline for one source: Stripe cash receipts.
 * PR V1 (Audit): Build the first "Daily Close PR" that only runs one check: check_bank_reconciliation.py.
 * Iterate: We'll get our cash rec auditable and automated now, then move on to the more complex revenue models.

This system makes the finance function a strategic enabler, not a bottleneck. I'm excited to build it.
